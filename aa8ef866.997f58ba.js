(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{176:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return p}));var a=n(3),r=n(7),i=(n(0),n(232)),o=["components"],s={title:"Exploring the links between creative execution and marketing effectiveness - Part III: Tesseract Pre-Trained Optical Character Recognition Models",author:"Marina Bermejo Sarmiento, Monica Brondholt Sorensen, Karin Sasaki",author_title:"Data Scientist Consultant",author_url:"mailto:inno@ekimetrics.com",header_image_url:"./img/blog/Eki_Meta_part_III.png",tags:["Object Detection","Optical Character Recognition","Marketing Mix Modelling","Deep Learning","Tesseract"],draft:!1,description:"In this Part III we explore the methodology for using Tesseract to detect text in creative images.",keywords:["Data Science","EkiLab","Ekimetrics","Eki.Lab","Eki","Machine Learning","Artificial Intelligence","Data Science for business","Operational Research","Optimization","Knapsack problem","Deep Reinforcement Learning"]},c={permalink:"/blog/2022/12/13/creative_execution_and_marketing_effectiveness_part_III",source:"@site/blog/2022-12-13-creative_execution_and_marketing_effectiveness_part_III.md",description:"In this Part III we explore the methodology for using Tesseract to detect text in creative images.",date:"2022-12-13T00:00:00.000Z",tags:[{label:"Object Detection",permalink:"/blog/tags/object-detection"},{label:"Optical Character Recognition",permalink:"/blog/tags/optical-character-recognition"},{label:"Marketing Mix Modelling",permalink:"/blog/tags/marketing-mix-modelling"},{label:"Deep Learning",permalink:"/blog/tags/deep-learning"},{label:"Tesseract",permalink:"/blog/tags/tesseract"}],title:"Exploring the links between creative execution and marketing effectiveness - Part III: Tesseract Pre-Trained Optical Character Recognition Models",readingTime:7.65,truncated:!0,prevItem:{title:"Exploring the links between creative execution and marketing effectiveness - Part IV: MMM for Creative Marketing Effectiveness",permalink:"/blog/2023/01/15/creative_execution_and_marketing_effectiveness_part_IV"},nextItem:{title:"Exploring the links between creative execution and marketing effectiveness - Part II Custom trained Detectron2 for OD",permalink:"/blog/2022/11/30/creative_execution_and_marketing_effectiveness_part_II"}},l=[{value:"Detecting Text with Tesseract",id:"detecting-text-with-tesseract",children:[]},{value:"Code snippets",id:"code-snippets",children:[{value:"Install required libraries",id:"install-required-libraries",children:[]},{value:"Import required libraries",id:"import-required-libraries",children:[]},{value:"Processing images",id:"processing-images",children:[]},{value:"Detect text",id:"detect-text",children:[]},{value:"Manipulate bounding boxes",id:"manipulate-bounding-boxes",children:[]}]},{value:"Useful Links",id:"useful-links",children:[]},{value:"Next article",id:"next-article",children:[]}],d={toc:l};function p(e){var t=e.components,s=Object(r.a)(e,o);return Object(i.b)("wrapper",Object(a.a)({},d,s,{components:t,mdxType:"MDXLayout"}),Object(i.b)("div",{align:"justify"},Object(i.b)("p",null,"This article is ",Object(i.b)("strong",{parentName:"p"},"Part III")," of a set of five technical articles that accompany a ",Object(i.b)("a",{parentName:"p",href:"https://ekimetrics.com/news-and-events/exploring-the-links-between-creative-execution-and-marketing-effectiveness-exclusivepreview"},"whitepaper")," written in collaboration between Meta and Ekimetrics. Object Detection (OD) and Optical Character Recognition (OCR) were used to detect specific features in creative images, such as faces, smiles, text, brand logos, etc. Then, in combination with impressions data, marketing mix models were used to investigate what objects, or combinations of objects in creative images in marketing campaigns, drive higher ROIs.\nIn this Part III we explore the methodology for using Tesseract to detect text in creative images.")),Object(i.b)("h2",{id:"detecting-text-with-tesseract"},"Detecting Text with Tesseract"),Object(i.b)("div",{align:"justify"},"Tesseract is an open-source optical character recognition (OCR) Engine that allows for the recognition of text characters within a digital image. It is an open-source resource, originally developed by Hewlett-Packard, and now managed by Google. This package does not have any parameters to optimise, but, as is exposed here, the basic performance of this resource can be improved with a combination of image processing and detected text correction.",Object(i.b)("p",null,"In this work, Tesseract was used to detect text in all images, in a process outlined in Figure 1. Performance of this detection tool was done using Confusion Matrices, to gain insight not only into the Accuracy, but also other metrics such as the True Positive and True Negative Rates.  ")),Object(i.b)("p",null,Object(i.b)("img",{alt:"screenshot-app",src:n(399).default})),Object(i.b)("div",{align:"center"}," Figure 1 - Three stage process by which the basic performance (accuracy) of Tesseract on the original images was improved by up to 28% points."),Object(i.b)("br",null),Object(i.b)("div",{align:"justify"},"To start with, the functionality was used on the original images to measure a baseline for performance on our sets of images. From this first step, we derived the following learnings:",Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"For general Text (both non-promotional Text and Promotional Text), the Accuracy is 69%, the True Positive Rate is around 65%, the False Positive Rate is about 35%."),Object(i.b)("li",{parentName:"ul"},"Tesseract does not recognise symbols such as % (which may indicate promotional text) accurately."),Object(i.b)("li",{parentName:"ul"},"Tesseract does not perform well on images that have a busy background."),Object(i.b)("li",{parentName:"ul"},"Tesseract does not recognise slanted Text.")),Object(i.b)("p",null,"Based on the low total volume of Promotional Text in our dataset, as well as the poor performance of Tesseract to detect Promotional Text, the decision was made to remove Promotional Text as one of the desired objects to study."),Object(i.b)("p",null,"Building on those learnings, we implemented a pipeline, outlined in Figure 2, that would help us improve the performance from baseline, by up to 28 percentage points on Accuracy : ")),Object(i.b)("p",null,Object(i.b)("img",{alt:"screenshot-app",src:n(400).default})),Object(i.b)("div",{align:"center"}," Figure 2 - Pipeline for pre-processing images before Optical Character Recognition Models, and correcting detected text."),Object(i.b)("br",null),Object(i.b)("div",{align:"justify"},Object(i.b)("p",null,"For Step 1, pre-processing methods included the following, as well as combinations of those (illustrated in Figure 3): ",Object(i.b)("strong",{parentName:"p"},"Binary Threshold, Sharpen, Normalisation, Histogram Equalisation, Histogram Adaptive Equalisation"),". As can be imagined, a processing method that enhances the performance of the detection method for one image, might decrease it for different images. Therefore, to ensure we obtained the highest accuracy for all images, we applied all pre-processing methods to all images, running Tesseract on each modified image, and keeping track of the text detected in each iteration. ")),Object(i.b)("p",null," ",Object(i.b)("img",{alt:"screenshot-app",src:n(401).default})),Object(i.b)("div",{align:"center"}," Figure 3 - Effect of various image processing methods on the original. Images for illustrative purposes. Original images sourced from ",Object(i.b)("a",{href:"https://unsplash.com/s/photos/coca-cola",target:"_top"},"unsplash.com")),Object(i.b)("br",null),Object(i.b)("div",{align:"justify"},"In Step 2 we use Tesseract to detect text in the pre-processed images. Step 3 consisted of removing any \u201cincorrect\u201d text, such as text inside the bounding boxes of Logo or Product objects, if the text was shorter than a threshold length (which depended on the brand), if it consisted of keywords, such as the brand name, or if it had ASCII characters.",Object(i.b)("p",null,"With the current methodology (figure 2), the accuracy cannot be improved any further by changing the length of text that is considered to be \u201ctrue\u201d Text. Furthermore, there is a trade-off between the True Negative Rate and the True Positive Rate, which helped us choose a threshold for the length of string to accept: Since Accuracy does not improve further after length 4, but this value does optimise the other two metrics, 4 characters long is the threshold chosen. ")),Object(i.b)("br",null),Object(i.b)("div",{align:"justify"},"The performance of Tesseract may be improved further by adding another step to the pipeline in figure 2, where the image is rotated several degrees, and after each rotation, text is detected. Due to time constraint issues, and the fact that we had already achieved a significant improvement above baseline and reached an accuracy of high 90s for some of the brands, we did not implement this step."),Object(i.b)("h2",{id:"code-snippets"},"Code snippets"),Object(i.b)("h3",{id:"install-required-libraries"},"Install required libraries"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"# To install tesseract\n# !sh apt-get -f -y install tesseract-ocr \n!sudo apt-get install tesseract-ocr -y\n\n# To install pytesseract\n!pip3 install pytesseract\n")),Object(i.b)("h3",{id:"import-required-libraries"},"Import required libraries"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"import pytesseract\nfrom sklearn.metrics import confusion_matrix, accuracy_score\nimport cv2\nfrom PIL import Image\n")),Object(i.b)("h3",{id:"processing-images"},"Processing images"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def normalise_img(image):\n            \n    # normalise original and detect\n    norm_img = np.zeros((image.shape[0], image.shape[1]))\n    normalised = cv2.normalize(image, norm_img, 0, 255, cv2.NORM_MINMAX)\n    normalised = cv2.threshold(normalised, 100, 255, cv2.THRESH_BINARY)[1]\n    normalised = cv2.GaussianBlur(normalised, (1, 1), 0)\n    \n    return normalised\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def threshold_image(image, threshold=200):\n    image = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)[1]\n    return image\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def remove_noise_and_smooth(image):\n\n    # convert to grayscale\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n    # blur\n    blur = cv2.GaussianBlur(gray, (0,0), sigmaX=33, sigmaY=33)\n\n    # divide\n    divide = cv2.divide(gray, blur, scale=255)\n\n    # otsu threshold\n    thresh = cv2.threshold(divide, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)[1]\n\n    # apply morphology\n    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))\n    morph = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)\n\n    return morph\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def im_to_gray(image):\n    # convert to grayscale \n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    return gray\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def create_binary(image):\n    # create binary - converting a colored image (RGB) into a black and white image - Adaptive binarization works based on the features of neighboring pixels (i.e) local window.\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    binary = cv2.threshold(image ,130,255,cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]\n    return binary\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def hist_equaliser(image):\n    # Image Contrast and Sharpness: histogram equalization\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    equalised = cv2.equalizeHist(gray)\n    return equalised\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def adaptive_hist_equaliser(image):\n    # Image Contrast and Sharpness: adaptive histogram equalization\n    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))\n    equalised = clahe.apply(gray)\n    return equalised\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def invert_image():\n    # invert the image - Color Inversion when different regions have different Foreground and Background colors\n    inverted = cv2.bitwise_not(image)\n    return inverted\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def im_blur(image):\n    # Blurring or Smoothing \n    averageBlur = cv2.blur(image, (5, 5))\n    return\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def im_gaussianBlur(image):\n    # Blurring or Smoothing (Gaussian Blur)\n    gaussian = cv2.GaussianBlur(image, (3, 3), 0)\n    return\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def im_medianBlur(image):\n    # Blurring or Smoothing (Median Blur (good at removing salt and pepper noises))\n    medianBlur = cv2.medianBlur(image, 9)\n    return\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def im_bilateralBlur(image):\n    # Blurring or Smoothing (Bilateral Filtering)\n    bilateral = cv2.bilateralFilter(image, 9, 75, 75)\n    return image\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},'def unsharp_mask(image, kernel_size=(5, 5), sigma=1.0, amount=1.0, threshold=0):\n    """Return a sharpened version of the image, using an unsharp mask."""\n    blurred = cv2.GaussianBlur(image, kernel_size, sigma)\n    sharpened = float(amount + 1) * image - float(amount) * blurred\n    sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))\n    sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))\n    sharpened = sharpened.round().astype(np.uint8)\n    if threshold > 0:\n        low_contrast_mask = np.absolute(image - blurred) < threshold\n        np.copyto(sharpened, image, where=low_contrast_mask)\n    return sharpened\n')),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def apply_filter_sharpen(image):\n    kernel = np.array([[-1,-1,-1], [-1,9,-1], [-1,-1,-1]])\n    image = cv2.filter2D(image, -1, kernel)\n    return image\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def im_erode_dilate(image):\n    # apply noise reduction techniques like eroding, dilating\n    kernel = np.ones((2,2),np.uint8)\n    image = cv2.erode(image, kernel, iterations = 1)\n    image = cv2.dilate(image, kernel, iterations = 1)\n    return image\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},'def process_image(image):\n\n    """\n    Example of a pipeline to pre-process an image.\n    """\n    \n    # convert to grayscale \n    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n     # create binary\n    image = cv2.threshold(image ,130,255,cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]\n\n    # invert the image\n    image = cv2.bitwise_not(image)\n\n    # apply noise reduction techniques like eroding, dilating\n    kernel = np.ones((2,2),np.uint8)\n    image = cv2.erode(image, kernel, iterations = 1)\n    image = cv2.dilate(image, kernel, iterations = 1)\n    \n    return image\n    \n')),Object(i.b)("h3",{id:"detect-text"},"Detect text"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def detect_text(image, brand_name, t, bboxes_file, verbose=True):\n    data = pytesseract.image_to_data(image, output_type=pytesseract.Output.DICT)\n    bboxes = get_bbox_pts(data)\n    data_out, bboxess, tt = check_text_ok(data, brand_name)\n    \n    return data, bboxes\n")),Object(i.b)("h3",{id:"manipulate-bounding-boxes"},"Manipulate bounding boxes"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"def get_bbox_pts(data):\n\n    \"\"\"\n    From the output of the text detection model, extract the [x1,x2,y1,y2] points.\n    \"\"\"\n    data['x1'] = []\n    data['x2'] = []\n    data['y1'] = []\n    data['y2'] = []\n    for i, txt in enumerate(data['text']):\n    \n        # extract the width, height, top and left position for that detected word\n        w = data[\"width\"][i]\n        h = data[\"height\"][i]\n        l = data[\"left\"][i]\n        t = data[\"top\"][i]\n        \n        # define all the surrounding box points\n        x1 = l\n        x2 = l + w\n        y1 = t\n        y2 = t + h\n\n        data['x1'].append(x1)\n        data['x2'].append(x2)\n        data['y1'].append(y1)\n        data['y2'].append(y2)\n        \n    return data\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},'def transform_bbox(bbox):\n\n    """\n    Transform Azure labels of valid set from [x,y,w,h] (in absolute numbers, prev. transformed) to [x,y,x1,y1].\n    """\n    x = bbox[0]\n    y = bbox[1]\n    w = bbox[2]\n    h = bbox[3]\n    \n    x1 = x + w\n    y1 = y + h\n\n    return [x,y,x1,y1]\n')),Object(i.b)("h2",{id:"useful-links"},"Useful Links"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"https://github.com/tesseract-ocr"},"Tesseract - Github")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"https://tesseract-ocr.github.io/tessdoc/Home.html"},"Tesseract - User Manual")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"https://pypi.org/project/pytesseract/"},"Pytesseract - Pypi"))),Object(i.b)("h2",{id:"next-article"},"Next article"),Object(i.b)("p",null,"In the next article, we outline the MMM process, focusing on how the creative elements are used as variables in a multivariate regression, as well as how the final ROIs were calculated."))}p.isMDXComponent=!0},232:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),d=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=d(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=d(n),u=a,m=p["".concat(o,".").concat(u)]||p[u]||b[u]||i;return n?r.a.createElement(m,s(s({ref:t},l),{},{components:n})):r.a.createElement(m,s({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},399:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/10-dc93d16eaa104bf23fe228afaf7bd6a2.PNG"},400:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/11-435bc20c4e2284716dcd7b9565a42098.PNG"},401:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/12-bdf7d0b4655f39b30eaa56e906ef8e6d.PNG"}}]);